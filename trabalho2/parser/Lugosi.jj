PARSER_BEGIN(Lugosi)
import java.io.*;
public class Lugosi {

  public static void main(String args[]) throws ParseException,IOException {
    
 Lugosi parser = new Lugosi(new FileInputStream(args[0]));
 parser.Lugosi();
  }

}

PARSER_END(Lugosi)

SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
}

TOKEN :
{
  <MAIN: "main">
| <ACHAVES: "{">
| <FCHAVES: "}">
| <VAR: "var">
| <PONTOEVIRGULA: ";">
| <TIPO: ("int" | "bool" | "float" | "let")>
| <IF: "if">
| <WHILE: "while">
| <DO: "do">
| <RETURN: "return">
| <PRINTIO: "printIO">
| <READIO: "readIO">
| <ATRIBUICAO: ":=">
| <APARENTESES:"(">
| <FPARENTESES:")">
| <FUNCTION: "function">
| <VIRGULA: "virgula">
| <TOKEN_NUMLITERAL:(["0"-"9"])+ ("."(["0"-"9"])+ )? ("E" ("+" | "-")? (["0"-"9"])+)?>
| <TRUE: "true">
| <FALSE: "false">
| <TOKEN_ID: ["a"-"z","A"-"Z"] ( ["a"-"z","A"-"Z","0"-"9"])* ("_")*>
//| <VOID: "void">
}

TOKEN :
{
 <NUM : (["0"-"9"])+ ("."(["0"-"9"])+)?>
 | <ID: ["a"-"z","A"-"Z"] ( ["a"-"z","A"-"Z","0"-"9"])* ("_"(["a"-"z","A"-"Z","0"-"9"])+)*>
 | <OP: "+" | "-" | "*" | "/" | "&&" | "||" | "<" | ">" | "==">
}

void Lugosi () :
{}
{

    main()
    (func())?
    <EOF>
}

void main():
{}
{
    <MAIN> <ACHAVES> VarDecl() SeqComandos() <FCHAVES>
}

void VarDecl():
{}
{
    (<VAR> <TIPO> <TOKEN_ID> <PONTOEVIRGULA>)*
}

//tipo

void SeqComandos():
{}
{
    (comando())*
}

//void comando():
//{}
//{
//    <TOKEN_ID> <ATRIBUICAO> exp() <PONTOEVIRGULA>
//    | <TOKEN_ID> <APARENTESES> (listaExp())? <FPARENTESES> <PONTOEVIRGULA>
//    | <IF> exp() <ACHAVES> SeqComandos() <FCHAVES> <PONTOEVIRGULA>
//    | <WHILE> exp() <DO> <ACHAVES> SeqComandos() <FCHAVES> <PONTOEVIRGULA>
//    | <TOKEN_ID> <ATRIBUICAO> <READIO> <APARENTESES> <FPARENTESES> <PONTOEVIRGULA>
//    | <RETURN> exp() <PONTOEVIRGULA>
//    | <PRINTIO> exp() <PONTOEVIRGULA>
//}

//void comando ():
//{}
//{
//	<TOKEN_ID> Comando2() | <IF> <APARENTESES> exp() <FPARENTESES> <ACHAVES> SeqComandos() <FCHAVES> <PONTOEVIRGULA>
//						| <WHILE> <APARENTESES> exp() <FPARENTESES> <DO> <ACHAVES> SeqComandos() <FCHAVES> <PONTOEVIRGULA>
//						| <DO> <ACHAVES> SeqComandos() <FCHAVES> <WHILE> <APARENTESES> exp() <FPARENTESES> <PONTOEVIRGULA>
//						| <RETURN> exp() <PONTOEVIRGULA>
//						| <PRINTIO> <APARENTESES> exp() <FPARENTESES> <PONTOEVIRGULA>
//
//}
//
//void Comando2 ():
//{}
//{
//	<ATRIBUICAO> exp() <PONTOEVIRGULA> | <APARENTESES> ( listaExp() )? <FPARENTESES> <PONTOEVIRGULA>
//}

void comando():
{}
{
    <TOKEN_ID> comandoL()
    | <IF> <APARENTESES> exp() <FPARENTESES> <ACHAVES> SeqComandos() <FCHAVES> <PONTOEVIRGULA>
    | <WHILE> <APARENTESES> exp() <FPARENTESES> <DO> <ACHAVES> SeqComandos() <FCHAVES> <PONTOEVIRGULA>
    | doWhileComando()
    | <RETURN> exp() <PONTOEVIRGULA>
    | <PRINTIO> <APARENTESES> exp() <FPARENTESES> <PONTOEVIRGULA>
}

//Para tirar a recursão
void comandoL ():
{}
{
	<ATRIBUICAO> exp() <PONTOEVIRGULA> | <APARENTESES> listaExp() <FPARENTESES> <PONTOEVIRGULA>
}

void doWhileComando():
{}
{
    <DO> <ACHAVES> SeqComandos() <FCHAVES> <WHILE> <APARENTESES> exp() <FPARENTESES> <PONTOEVIRGULA>
}


void exp ():
{}
{
    (<APARENTESES> exp() <OP> exp() <FPARENTESES>)| fator()
}

void fator():
{}
{
    <TOKEN_ID>
    | (<APARENTESES> (listaExp())? <FPARENTESES>)
    | <TOKEN_NUMLITERAL>
    | <TRUE>
    | <FALSE>
}

//LISTAEXP -> EXP | LISTAEXP "," EXP

//Eliminacao recursao:
//LISTAEXP -> EXP LISTAEXP'
//LISTAEXP' -> "," EXP LISTAEXP' | ε


void listaExp():
{}
{
    exp() listaExpL()
}

void listaExpL():
{}
{
    ( <VIRGULA> exp() listaExpL() )?
}

void func():
{}
{
    (<FUNCTION> <TIPO> <TOKEN_ID> <APARENTESES> (listaArg())? <FPARENTESES> <ACHAVES> VarDecl() SeqComandos() <FCHAVES>)+
}

//LISTAARG -> TIPO TOKEN_id | LISTAARG "," TIPO TOKEN_id

//Eliminacao recursao:
//LISTAARG -> TIPO TOKEN_id LISTAARG'
//LISTAARG' -> "," TIPO TOKEN_id LISTAARG' | ε

void listaArg():
{}
{
    <TIPO> <TOKEN_ID> listaArgL()
}

void listaArgL():
{}
{
    (<VIRGULA> <TIPO> <TOKEN_ID> listaArgL())?
}